#include <iostm8S207c8.h>
#include "slrc632.h"





static void RC632_DelayMs(unsigned short ms)
{
    unsigned short i;      
  
    while(ms--)
    {
       for(i=0;i<246;i++)  asm("nop");
    }
}
//============================================================
void outportb(unsigned char Addr,unsigned char Dat)
{
        PB_DDR = 0xFF;                  //PB Output
        asm("nop");
        
        RC632_NCS = 0;
        asm("nop");
        
        RC632_DATA_OUT = Addr;
        asm("nop");
        
        RC632_ALE = 0;
        asm("nop");
        
        RC632_DATA_OUT = Dat;
        asm("nop");
        
        RC632_WR = 0;
        asm("nop");
        
        RC632_WR = 1;
        asm("nop");
        
        RC632_ALE = 1;
        asm("nop");
        
        RC632_NCS = 1;
        asm("nop");
}

unsigned char inportb(unsigned char Addr)
{
        unsigned char Dat;
        
        PB_DDR = 0xFF;                  //PB Output
        asm("nop");
        
        RC632_NCS  = 0;
        asm("nop");
        
        RC632_DATA_OUT = Addr;
        asm("nop");
        
        RC632_ALE = 0;
        asm("nop");
        
        PB_DDR = 0x00;                  //PB Input
        asm("nop");
        
        RC632_RD = 0;
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        asm("nop");
        Dat = RC632_DATA_IN;
        asm("nop");
        
        RC632_RD = 1;
        asm("nop");
        
        RC632_ALE = 1;
        asm("nop");
        
        RC632_NCS = 1;
        asm("nop");
        
        return Dat;
}
//============================================================													
unsigned char ReadRawRC(unsigned char Address)
{
	return inportb(Address);	   
}


void  WriteRawRC(unsigned char Address, unsigned char value)
{
	outportb(Address,value);
}

/////////////////////////////////////////////////////////////////////
//初始化RC632
/////////////////////////////////////////////////////////////////////
unsigned char Rc632Ready(void)
{
    char status;

    PC_DDR |= 0xC0;   //11000000           //Reset IO Port
    PC_CR1 |= 0xC0;
    PC_ODR |= 0xC0;
    
    PE_DDR |= 0x8A;   //10001010
    PE_DDR &= 0xFA;   //11111010
    PE_CR1 |= 0x8d;
    PE_ODR |= 0x8F;
    
    PA_DDR |= 0x40;   //01000000
    PA_CR1 |= 0x40;
    PA_ODR |= 0X40;
    
    PB_CR1 = 0xff;
    PB_CR2 = 0x00;
    
    RC632_DelayMs(100);
    status = PcdReset();
    if(status != MI_OK)
    {
        RC632_DelayMs(10);
        status = PcdReset();
    }
    if(status != MI_OK)
    {
        RC632_DelayMs(10);
        status = PcdReset();
    } 
    return status;      
}
/////////////////////////////////////////////////////////////////////
//复位并初始化RC632
//注意:RC500上电后应延时500ms才能可靠初始化
/////////////////////////////////////////////////////////////////////
char PcdReset()
{
   char status = MI_OK;
   char n = 0xFF;
   unsigned int i = 3000;

   RC632_NCS=0;
   RC632_RSTPD=0;
   RC632_DelayMs(50);
   RC632_RSTPD=1;
   RC632_DelayMs(5);
   RC632_RSTPD=0;
   RC632_NCS=0;
   RC632_DelayMs(5);

   while (i!=0 && n)
   {
      n = ReadRawRC(RegCommand);
      i--;
   }

   if (i != 0)
   {
      WriteRawRC(RegPage,0x80);
      n = 0x80;
      while ( (i!=0) && (n&0x80) )
      {
          n = ReadRawRC(RegCommand);
          i--;
      }
      if (i==0 || (n&0xFF))
      {   
          status = (unsigned char)MI_RESETERR;   
      }
   }
   else
   {    
      status = (unsigned char)MI_RESETERR;     
   }
   
   if (status == MI_OK)
   {    WriteRawRC(RegPage,0x0);  }
   
   return status;
}

//////////////////////////////////////////////////////////////////////
//设置RC632的工作方式 
//////////////////////////////////////////////////////////////////////
char PcdConfigISOType(unsigned char type)
{
   
   if (type == 'A')                    //ISO14443_A
   { 
       ClearBitMask(RegControl,0x08);

       WriteRawRC(RegClockQControl,0x0);
       WriteRawRC(RegClockQControl,0x40);
       RC632_DelayMs(1);                   // wait approximately 100 us - calibration in progress
       ClearBitMask(RegClockQControl,0x40);
       
       WriteRawRC(RegTxControl,0x5b);
       WriteRawRC(RegCwConductance,0x0F);
       WriteRawRC(RegModConductance,0x3F);       
       WriteRawRC(RegCoderControl,0x19);
       WriteRawRC(RegModWidth,0x13);             
       WriteRawRC(RegModWidthSOF,0x00);          
       WriteRawRC(RegTypeBFraming,0x00);
       
       WriteRawRC(RegRxControl1,0x73);
       WriteRawRC(RegDecoderControl,0x08);
       WriteRawRC(RegBitPhase,0xAD);	
       WriteRawRC(RegRxThreshold,0xAA);
       WriteRawRC(RegBPSKDemControl,0);
       WriteRawRC(RegRxControl2,0x41);

       WriteRawRC(RegRxWait,0x06);
       WriteRawRC(RegChannelRedundancy,0x0F);    
       WriteRawRC(RegCRCPresetLSB,0x63);
       WriteRawRC(RegCRCPresetMSB,0x63);
       WriteRawRC(RegTimeSlotPeriod,0x00);
       WriteRawRC(RegMfOutSelect,0x00);
       WriteRawRC(RFU27,0x00);   	      

       WriteRawRC(RegFIFOLevel,0x3F);
       WriteRawRC(RegTimerClock,0x07);
       WriteRawRC(RegTimerReload,0x0A);
       WriteRawRC(RegTimerControl,0x06);   
       WriteRawRC(RegIRqPinConfig,0x02);      
       WriteRawRC(RFU2E,0x00);
       WriteRawRC(RFU2F,0x00);	  

       PcdSetTmo(106);
       RC632_DelayMs(1);
       PcdAntennaOn();

   }
   else if (type == 'B')
   {
     ClearBitMask(RegControl,0x08);

       WriteRawRC(RegClockQControl,0x0);
       WriteRawRC(RegClockQControl,0x40);      	//0x3f, Q时钟控制	  相位
       RC632_DelayMs(1);  
       ClearBitMask(RegClockQControl,0x40);
    //////////////发送参数设置/////////////////   
       WriteRawRC(RegTxControl,0x6b);         		//0x4b, 13.56MHz		发送控制寄存器 	  0x4b选用内部输出，0x6b选用MFIN输出
       WriteRawRC(RegCwConductance,0x18);		 	//0x3f, 设置输出驱动的电导系数	   调输出功率（距离）18
       WriteRawRC(RegModConductance,0x01);	 	//0x06, 幅移键控ASk 12%       幅度调节
       WriteRawRC(RegCoderControl,0x20);          //0x20, TypeB,波特率106kbps, NRZ编码
       WriteRawRC(RegModWidth,0x13);              //脉冲宽度调制 13
       WriteRawRC(RegModWidthSOF,0x3F);           //SOF = 9.44 us
       WriteRawRC(RegTypeBFraming,0x00);          //0x23, 定义ISO14443B帧格式		 //调字节之间距离，是否要包头包尾和宽度
     //////////////接收参数设置/////////////////   
       WriteRawRC(RegRxControl1,0x73);              //接收器的增益调节	 73
       WriteRawRC(RegDecoderControl,0x19);			  //BPSK
       WriteRawRC(RegBitPhase,0xAD);	
       WriteRawRC(RegRxThreshold,0x88);         //0x44, 可接收的最小信号强度  88
       WriteRawRC(RegBPSKDemControl,0x7E);        //0x3e, 忽略EOF,打开高通滤波	 7e
       WriteRawRC(RegRxControl2,0x01);

       WriteRawRC(RegRxWait,0x06);                //0x06, 设置接收延时
       WriteRawRC(RegChannelRedundancy,0x2C);      //0x2c, TypeB接收冗余校验   
       WriteRawRC(RegCRCPresetLSB,0xFF);         //0xff, CRC预设值
       WriteRawRC(RegCRCPresetMSB,0xFF);
       WriteRawRC(RegTimeSlotPeriod,0x00);
       WriteRawRC(RegMfOutSelect,0x05);		    //接收引脚
	 //  WriteRawRC(RegTestDigiSelect,0xF4);	
       WriteRawRC(RFU27,0x00);   	      

       WriteRawRC(RegFIFOLevel,0x3F);
       WriteRawRC(RegTimerClock,0x07);
       WriteRawRC(RegTimerReload,0x0A);
       WriteRawRC(RegTimerControl,0x06);  
       WriteRawRC(RegIRqPinConfig,0x02);       
       WriteRawRC(RFU2E,0x00);
       WriteRawRC(RFU2F,0x00);
       PcdSetTmo(106);
       RC632_DelayMs(1000);
       PcdAntennaOn();
   }
   else if (type == 'r')
   {
       ClearBitMask(RegControl,0x08);

       WriteRawRC(RegClockQControl,0x0);
       WriteRawRC(RegClockQControl,0x40);
       RC632_DelayMs(1); 
       ClearBitMask(RegClockQControl,0x40);
       
       WriteRawRC(RegTxControl,0x4b);//8);//?0x4b
       WriteRawRC(RegCwConductance,0x06);
       WriteRawRC(RegModConductance,0x03);       
       WriteRawRC(RegCoderControl,0x20);
       WriteRawRC(RegModWidth,0x13);             
       WriteRawRC(RegModWidthSOF,0x00);          
       WriteRawRC(RegTypeBFraming,0x3B);
       
       WriteRawRC(RegRxControl1,0x73);
       WriteRawRC(RegDecoderControl,0x19);
       WriteRawRC(RegBitPhase,0xAD);	
       WriteRawRC(RegRxThreshold,0x88);
       WriteRawRC(RegBPSKDemControl,0x3E);
       WriteRawRC(RegRxControl2,0x01);

       WriteRawRC(RegRxWait,0x06);
       WriteRawRC(RegChannelRedundancy,0x2C);    
       WriteRawRC(RegCRCPresetLSB,0xFF);
       WriteRawRC(RegCRCPresetMSB,0xFF);
       WriteRawRC(RegTimeSlotPeriod,0x00);
       WriteRawRC(RegMfOutSelect,0x00);
       WriteRawRC(RFU27,0x00);   	      

       WriteRawRC(RegFIFOLevel,0x1A);
       WriteRawRC(RegTimerClock,0x07);
       WriteRawRC(RegTimerReload,0x0A);
       WriteRawRC(RegTimerControl,0x06);  
       WriteRawRC(RegIRqPinConfig,0x02);       
       WriteRawRC(RFU2E,0x00);
       WriteRawRC(RFU2F,0x00);	 
       PcdSetTmo(106);
       RC632_DelayMs(1);
       PcdAntennaOn();
   }
   else if (type == 's')
   {
       ClearBitMask(RegControl,0x08);

       WriteRawRC(RegClockQControl,0x0);
       WriteRawRC(RegClockQControl,0x40);
       RC632_DelayMs(1);  
       ClearBitMask(RegClockQControl,0x40);
       
       WriteRawRC(RegTxControl,0x4b);
       WriteRawRC(RegCwConductance,0x06);
       WriteRawRC(RegModConductance,0x03);       
       WriteRawRC(RegCoderControl,0x20);
       WriteRawRC(RegModWidth,0x13);             
       WriteRawRC(RegModWidthSOF,0x00);          
       WriteRawRC(RegTypeBFraming,0x18);
       
       WriteRawRC(RegRxControl1,0x73);
       WriteRawRC(RegDecoderControl,0x19);
       WriteRawRC(RegBitPhase,0xAD);	
       WriteRawRC(RegRxThreshold,0x88);
       WriteRawRC(RegBPSKDemControl,0x3E);
       WriteRawRC(RegRxControl2,0x01);
 //      WriteRawRC(RegClockQControl,0x00);//?

       WriteRawRC(RegRxWait,0x06);
       WriteRawRC(RegChannelRedundancy,0x2C);    
       WriteRawRC(RegCRCPresetLSB,0xFF);
       WriteRawRC(RegCRCPresetMSB,0xFF);
       WriteRawRC(RegTimeSlotPeriod,0x00);
       WriteRawRC(RegMfOutSelect,0x00);
       WriteRawRC(RFU27,0x00);   	      

       WriteRawRC(RegFIFOLevel,0x3F);
       WriteRawRC(RegTimerClock,0x07);
       WriteRawRC(RegTimerReload,0x0A);
       WriteRawRC(RegTimerControl,0x06);  
       WriteRawRC(RegIRqPinConfig,0x02);       
       WriteRawRC(RFU2E,0x00);
       WriteRawRC(RFU2F,0x00);
       PcdSetTmo(106);
       RC632_DelayMs(1);
       PcdAntennaOn();
   }
   else if (type == '1')					  	 //ISO15693
   {
       ClearBitMask(RegControl,0x08);

       WriteRawRC(RegTxControl,0x48);
       WriteRawRC(RegCwConductance,0x38);
       WriteRawRC(RegModConductance,0x05);       // must be measured for 15% Modulation Index
       WriteRawRC(RegCoderControl,0x2F);         // 52.97kHz, 1-4 coding
       WriteRawRC(RegModWidth,0x3F);             // Modulation width: 9.44us
       WriteRawRC(RegModWidthSOF,0x3F);          // Standard mode: 9.44us
       WriteRawRC(RegTypeBFraming,0x00);
       
       WriteRawRC(RegRxControl1,0x87);
       WriteRawRC(RegDecoderControl,0x34);
       WriteRawRC(RegBitPhase,0xcd);
       WriteRawRC(RegRxThreshold,0x4c);
       WriteRawRC(RegBPSKDemControl,0);
       WriteRawRC(RegRxControl2,0x01);
       WriteRawRC(RegClockQControl,0x00);

       WriteRawRC(RegRxWait,0x08);
       WriteRawRC(RegChannelRedundancy,0x2C);    // Enable CRC TX/RX
       WriteRawRC(RegCRCPresetLSB,0xFF);
       WriteRawRC(RegCRCPresetMSB,0xFF);
       WriteRawRC(RegTimeSlotPeriod,  0xbf);
       WriteRawRC(RegMfOutSelect,0x05);         // enable SIGOUT = envelope
       WriteRawRC(RFU27,0x00);   	      

       WriteRawRC(RegFIFOLevel,0x38);
       WriteRawRC(RegTimerClock,0x0B);
       WriteRawRC(RegTimerReload,0x00);
       WriteRawRC(RegTimerControl,0x02);         // TStopRxEnd=0,TStopRxBeg=1,
       WriteRawRC(RFU2E,0x00);
       WriteRawRC(RFU2F,0x00);

       RC632_DelayMs(1);
       PcdAntennaOn();
   }
   else{ return -1; }
   return MI_OK;
}

/////////////////////////////////////////////////////////////////////
//置RC632寄存器位
//input:reg=寄存器地址
//      mask=置位值
/////////////////////////////////////////////////////////////////////
void SetBitMask(unsigned char reg,unsigned char mask)  
{
    char tmp = 0x00;
   tmp = ReadRawRC(reg);
   WriteRawRC(reg,tmp | mask);  // set bit mask
}

/////////////////////////////////////////////////////////////////////
//清RC632寄存器位
//input:reg=寄存器地址
//      mask=清位值
/////////////////////////////////////////////////////////////////////
void ClearBitMask(unsigned char reg,unsigned char mask)  
{
    char tmp = 0x00;
   tmp = ReadRawRC(reg);
   WriteRawRC(reg, tmp & ~mask);  // clear bit mask
} 

/////////////////////////////////////////////////////////////////////
//设置RC632定时器
//input:tmolength=设置值
/////////////////////////////////////////////////////////////////////
void PcdSetTmo(unsigned char tmoLength)
{
   switch(tmoLength)
   {  
      case 0:                         // (0.302 ms) FWI=0
         WriteRawRC(RegTimerClock,0x07); // TAutoRestart=0,TPrescale=128
         WriteRawRC(RegTimerReload,0x21);// TReloadVal = 'h21 =33(dec) 
         break;
      case 1:                         // (0.604 ms) FWI=1
         WriteRawRC(RegTimerClock,0x07); // TAutoRestart=0,TPrescale=128
         WriteRawRC(RegTimerReload,0x41);// TReloadVal = 'h41 =65(dec) 
         break;
      case 2:                         // (1.208 ms) FWI=2
         WriteRawRC(RegTimerClock,0x07); // TAutoRestart=0,TPrescale=128
         WriteRawRC(RegTimerReload,0x81);// TReloadVal = 'h81 =129(dec) 
         break;
      case 3:                         // (2.416 ms) FWI=3
         WriteRawRC(RegTimerClock,0x09); // TAutoRestart=0,TPrescale=4*128
         WriteRawRC(RegTimerReload,0x41);// TReloadVal = 'h41 =65(dec) 
         break;
      case 4:                         // (4.833 ms) FWI=4
         WriteRawRC(RegTimerClock,0x09); // TAutoRestart=0,TPrescale=4*128
         WriteRawRC(RegTimerReload,0x81);// TReloadVal = 'h81 =129(dec) 
         break;
      case 5:                         // (9.666 ms) FWI=5
         WriteRawRC(RegTimerClock,0x0B); // TAutoRestart=0,TPrescale=16*128
         WriteRawRC(RegTimerReload,0x41);// TReloadVal = 'h41 =65(dec) 
         break;
      case 6:                         // (19.33 ms) FWI=6
         WriteRawRC(RegTimerClock,0x0B); // TAutoRestart=0,TPrescale=16*128
         WriteRawRC(RegTimerReload,0x81);// TReloadVal = 'h81 =129(dec) 
         break;
      case 7:                         // (38.66 ms) FWI=7
         WriteRawRC(RegTimerClock,0x0D); // TAutoRestart=0,TPrescale=64*128
         WriteRawRC(RegTimerReload,0x41);// TReloadVal = 'h41 =65(dec) 
         break;
      case 8:                         // (77.32 ms) FWI=8
         WriteRawRC(RegTimerClock,0x0D); // TAutoRestart=0,TPrescale=64*128
         WriteRawRC(RegTimerReload,0x81);// TReloadVal = 'h81 =129(dec) 
         break;
      case 9:                         // (154.6 ms) FWI=9
         WriteRawRC(RegTimerClock,0x0F); // TAutoRestart=0,TPrescale=256*128
         WriteRawRC(RegTimerReload,0x41);// TReloadVal = 'h41 =65(dec) 
         break;
      case 10:                        // (309.3 ms) FWI=10
         WriteRawRC(RegTimerClock,0x0F); // TAutoRestart=0,TPrescale=256*128
         WriteRawRC(RegTimerReload,0x81);// TReloadVal = 'h81 =129(dec) 
         break;
      case 11:                        // (618.6 ms) FWI=11
         WriteRawRC(RegTimerClock,0x13); // TAutoRestart=0,TPrescale=4096*128
         WriteRawRC(RegTimerReload,0x11);// TReloadVal = 'h21 =17(dec) 
         break;
      case 12:                        // (1.2371 s) FWI=12
         WriteRawRC(RegTimerClock,0x13); // TAutoRestart=0,TPrescale=4096*128
         WriteRawRC(RegTimerReload,0x21);// TReloadVal = 'h41 =33(dec) 
         break;
      case 13:                        // (2.4742 s) FWI=13
         WriteRawRC(RegTimerClock,0x13); // TAutoRestart=0,TPrescale=4096*128
         WriteRawRC(RegTimerReload,0x41);// TReloadVal = 'h81 =65(dec) 
         break;
      case 14:                        // (4.9485 s) FWI=14
         WriteRawRC(RegTimerClock,0x13); // TAutoRestart=0,TPrescale=4096*128
         WriteRawRC(RegTimerReload,0x81);// TReloadVal = 'h81 =129(dec) 
         break;
      case 15:                        // (4.9485 s) FWI=14
         WriteRawRC(RegTimerClock,0x9); // TAutoRestart=0,TPrescale=4096*128
         WriteRawRC(RegTimerReload,0x0ff);// TReloadVal = 'h81 =129(dec) 
         break;
      default:                       // 
         WriteRawRC(RegTimerClock,0x19); // TAutoRestart=0,TPrescale=128
         WriteRawRC(RegTimerReload,tmoLength);// TReloadVal = 'h6a =tmoLength(dec) 
         break;
   }     
   WriteRawRC(RegTimerControl,0X06);
}
/////////////////////////////////////////////////////////////////////
//开启天线  
//每次启动或关闭天险发射之间应至少有1ms的间隔
/////////////////////////////////////////////////////////////////////
char PcdAntennaOn()
{
    unsigned char i;
    i = ReadRawRC(RegTxControl);
    if (i & 0x03)
    {   
        return MI_OK;
    }
    else
    {
        SetBitMask(RegTxControl, 0x03);
        return MI_OK;
    }
}

/////////////////////////////////////////////////////////////////////
//关闭天线
/////////////////////////////////////////////////////////////////////
char PcdAntennaOff()
{
    ClearBitMask(RegTxControl, 0x03);
    return MI_OK;
}


